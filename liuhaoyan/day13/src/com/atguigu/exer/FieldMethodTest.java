package com.atguigu.exer;

/*练习：
1.若子类重写了父类方法，就意味着子类里定义的方法  彻底覆盖了父类里的同名方法，
系统不可能把父类的方法转移到子类中

Base b = s; //多态性
Base b = new Sub(); 

编译看左，运行看右
属性看左，方法向右？

2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，
这个实例变量依然   不可能覆盖父类中定义的实例变量
*/
class Base{
	int count = 10;
	
	public void display() {
		System.out.println(this.count);
	}
}
class Sub extends Base{
	int count = 20;
	
	public void display() {
		System.out.println(this.count);
	}
}

public class FieldMethodTest {
	public static void main(String[] args) {
	Sub s = new Sub();
	System.out.println(s.count); //20 现在子类里找找不到再找父类 但两个都在内存地址中
	s.display();//20
	
	//==:对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同
	Base b = s; //多态性
	System.out.println(b == s); //true 两个同时指向了堆空间中的对象
	System.out.println(b.count); //10
	b.display(); //10
}
}
